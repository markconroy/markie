var et = Object.defineProperty; var it = (o, t, e) => t in o ? et(o, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : o[t] = e; var r = (o, t, e) => it(o, typeof t != "symbol" ? t + "" : t, e); var S = class { constructor(t) { r(this, "_distinctEvent"); r(this, "_boundedEvents", []); this._distinctEvent = t?.distinctEvent ?? !1 } get boundedEvents() { return this._boundedEvents } dispose() { this.unbindAll(), this._boundedEvents = [] } bind(t, e, i, s, l = "") { let n = Array.isArray(e) ? e : [e]; if (typeof t?.forEach == "function") t.forEach(a => { for (let h of n) (!this._distinctEvent || this._distinctEvent && !this.hasBinding(a, h)) && (a.addEventListener(h, i, s), this._boundedEvents.push({ element: a, eventName: h, listener: i, groupName: l })) }); else for (let a of n) (!this._distinctEvent || this._distinctEvent && !this.hasBinding(t, a)) && (t.addEventListener(a, i, s), this._boundedEvents.push({ element: t, eventName: a, listener: i, groupName: l })) } hasBinding(t, e) { return this._boundedEvents.some(i => i.element === t && (!e || i.eventName === e)) } unbind(t, e, i) { if (t) { let s = Array.isArray(t) ? t : [t], l = Array.isArray(e) ? e || "" : [e || ""]; for (let n of s) { i || (i = this._boundedEvents.find(a => { if (a.element === n && (!e || a.eventName === e)) return a.listener })); for (let a of l) n?.removeEventListener?.(a, i) } } } unbindAll(t) { if (t) { let e = Array.isArray(t) ? t : [t]; for (let i = this._boundedEvents.length - 1; i >= 0; --i) { let s = this._boundedEvents[i]; if (e.some(l => l === s.groupName)) { let { element: l, eventName: n, listener: a } = s; this.unbind(l, n, a), this._boundedEvents.splice(i, 1) } } } else for (; this._boundedEvents.length > 0;) { let e = this._boundedEvents.pop(), { element: i, eventName: s, listener: l } = e; this.unbind(i, s, l) } } }; var Y = typeof window < "u" && window.multipleSelect !== void 0 ? window.multipleSelect : { locales: {} }, st = { formatSelectAll() { return "[Select all]" }, formatAllSelected() { return "All selected" }, formatCountSelected(o, t) { return `${o} of ${t} selected` }, formatNoMatchesFound() { return "No matches found" }, formatOkButton() { return "OK" } }; Y.locales["en-US"] = st; var _ = Y.locales; var lt = 50, ot = 4, J = { name: "", placeholder: "", classes: "", classPrefix: "", data: void 0, locale: void 0, selectAll: !0, single: void 0, singleRadio: !1, multiple: !1, hideOptgroupCheckboxes: !1, multipleWidth: 80, width: void 0, dropWidth: void 0, maxHeight: 250, maxHeightUnit: "px", position: "bottom", displayValues: !1, displayTitle: !1, displayDelimiter: ", ", minimumCountSelected: 3, ellipsis: !1, isOpen: !1, keepOpen: !1, openOnHover: !1, container: null, filter: !1, filterGroup: !1, filterPlaceholder: "", filterAcceptOnEnter: !1, filterByDataLength: void 0, customFilter(o) { let { text: t, label: e, search: i } = o; return (e || t || "").includes(i) }, showClear: !1, autoAdjustDropHeight: !1, autoAdjustDropPosition: !1, autoAdjustDropWidthByTextSize: !1, adjustedHeightPadding: 10, useSelectOptionLabel: !1, useSelectOptionLabelToHtml: !1, navigationHighlight: !0, infiniteScroll: !1, virtualScroll: !0, cssStyler: () => null, textTemplate: o => o.innerHTML.trim(), labelTemplate: o => o.label, onOpen: () => !1, onClose: () => !1, onCheckAll: () => !1, onUncheckAll: () => !1, onFocus: () => !1, onBlur: () => !1, onOptgroupClick: () => !1, onBeforeClick: () => !0, onClick: () => !1, onFilter: () => !1, onFilterClear: () => !1, onClear: () => !1, onAfterCreate: () => !1, onDestroy: () => !1, onAfterDestroy: () => !1, onDestroyed: () => !1 }, nt = ["init", "getOptions", "refreshOptions", "getSelects", "setSelects", "enable", "disable", "open", "close", "check", "uncheck", "checkAll", "uncheckAll", "checkInvert", "focus", "blur", "refresh", "destroy"]; Object.assign(J, _["en-US"]); var rt = { BLOCK_ROWS: lt, CLUSTER_BLOCKS: ot, DEFAULTS: J, METHODS: nt }, m = rt; function j(o, t, e = !1) { let i = Object.keys(o), s = Object.keys(t); if (e && i.length !== s.length) return !1; for (let l of i) if (s.includes(l) && o[l] !== t[l]) return !1; return !0 } function L(o) { let t = () => { let s = {}; for (let l in o) Object.prototype.hasOwnProperty.call(o, l) && (s[l] = L(o[l])); return s }, e = () => o.map(s => L(s)), i = Object.prototype.toString.call(o).slice(8, -1).toLowerCase(); return i === "object" ? t() : i === "array" ? e() : o } function I(o) { return o != null && o !== "" } function $(o, t) { return typeof o == "object" ? Object.fromEntries(t ? Object.entries(o).filter(([e, i]) => !I(i) && !t.includes(e) || I(i)) : Object.entries(o).filter(([e, i]) => I(i))) : o } function W(o) { let t = 0; return o.forEach((e, i) => { e.type === "optgroup" ? (e._key = `group_${i}`, e.visible = typeof e.visible > "u" ? !0 : e.visible, e.children.forEach((s, l) => { s && (s.visible = typeof s?.visible > "u" ? !0 : s.visible, s.divider || (s._key = `option_${i}_${l}`, t += 1)) })) : (e.visible = typeof e.visible > "u" ? !0 : e.visible, e.divider || (e._key = `option_${i}`, t += 1)) }), t } function b(o, t, e) { if (Array.isArray(o)) for (let i of o) { if (i[t] === e || i[t] === `${+i[t]}` && +i[t] === e) return i; if (i.type === "optgroup") { for (let s of i.children) if (s && (s[t] === e || s[t] === `${+s[t]}` && +s[t] === e)) return s } } } function G(o) { return o.replace(/(\b)(on[a-z]+)(\s*)=([^>]*)|javascript:([^>]*)[^>]*|(<\s*)(\/*)script([<>]*).*(<\s*)(\/*)script(>*)|(&lt;|&#60;)(\/*)(script|script defer)(.*)(&#62;|&gt;|&gt;">)/gi, "") } function H(o) { return Object.keys(o).forEach(t => o[t] === void 0 ? delete o[t] : ""), o } function at(o) { return o.replace(/[\W_]+(.)/g, (t, e) => e.toUpperCase()) } function f(o, t) { if (typeof o != "string") return o; if (typeof t == "function") return t(o); if (typeof o.normalize == "function") return o.normalize("NFD").replace(/[\u0300-\u036F]/g, ""); throw new Error("[Multiple-Select-Vanilla] `normalize()` function is not defined, you can optionally provide a custom parser via the `diacriticParser` option.") } function T(o) { let t = 0, e = 0, i = 0, s = 0, l = window.innerHeight ?? 0, n = window.innerWidth ?? 0, a = Z(), h = a.top, c = a.left, d = k(o); if (d) { let u = d.top ?? 0, E = d.left ?? 0; e = u - h, t = l - (u - h), i = E - c, s = n - (E - c) } return { top: e, bottom: t, left: i, right: s } } function O(o = "") { return o.split(" ").filter(t => t) } function p(o, t, e) { let i = document.createElement(o); return t && Object.keys(t).forEach(s => { let l = t[s]; typeof l == "object" ? Object.assign(i[s], l) : i[s] = t[s] }), e?.appendChild && e.appendChild(i), i } function F(o, t, e) { let i = o.props?.innerHTML ? Q(o.props, "innerHTML") : o.props, s = p(o.tagName, $(i, ["className", "title", "style"]), t), l = e; if (l || (l = s), o.props.innerHTML && (s.innerHTML = o.props.innerHTML), o.attrs) for (let n of Object.keys(o.attrs)) s.setAttribute(n, o.attrs[n]); if (o.children) for (let n of o.children) F(n, s, l); return t?.appendChild(s), s } function y(o) { return o.hasOwnProperty("tagName") ? F(o) : document.createElement("li") } function g(o) { for (; o?.firstChild;)o.lastChild && o.removeChild(o.lastChild); return o } function k(o) { if (!o) return; let t = o?.getBoundingClientRect?.(), e = 0, i = 0, s = 0, l = 0; return t?.top !== void 0 && t.left !== void 0 && (e = t.top + window.pageYOffset, i = t.left + window.pageXOffset, l = t.right, s = t.bottom), { top: e, left: i, bottom: s, right: l } } function v(o, t, e) { if (!o) return 0; let i = Number.parseFloat(o.style[e]); if (!i || Number.isNaN(i)) { switch (t) { case "outer": i = o[e === "width" ? "offsetWidth" : "offsetHeight"]; break; case "scroll": i = o[e === "width" ? "scrollWidth" : "scrollHeight"]; break; case "inner": default: i = o[e === "width" ? "clientWidth" : "clientHeight"]; break }i = o.getBoundingClientRect()[e] } if (!i || Number.isNaN(i)) { let s = o.style.display, l = o.style.position; o.style.display = "block", o.style.position = "absolute"; let n = window.getComputedStyle(o)[e]; i = Number.parseFloat(n), Number.isNaN(i) && (i = 0), o.style.display = s, o.style.position = l } return i || 0 } function N(o, t) { let e = null, i = o?.parentElement; for (; i;) { let [s, l, n, a] = t.match(/^([a-z]*)([#.]{1})([a-z\-]+)$/i) || []; if (n && a) for (let h of a.replace(n, "").split(" ")) i.classList.contains(h) && (l ? i?.tagName.toLowerCase() === l && (e = i) : e = i); i = i.parentElement } return e } function q(o, t) { o.parentNode?.insertBefore(t, o.nextSibling) } function Q(o, t) { let { [t]: e, ...i } = o; return i } function R(o, t) { o?.style && (o.style.display = o.style.display === "none" && t !== !1 || t === !0 ? "block" : "none") } function ct(o, t) { if (o?.classList) { let i = t === !0 || !o.classList.contains("selected") ? "add" : "remove"; o.classList[i]("selected") } } function Z() { return { left: window.pageXOffset || document.documentElement.scrollLeft || 0, top: window.pageYOffset || document.documentElement.scrollTop || 0 } } var x = class { constructor(t) { r(this, "clusterRows"); r(this, "cache"); r(this, "scrollEl"); r(this, "blockHeight"); r(this, "clusterHeight"); r(this, "contentEl"); r(this, "parentEl"); r(this, "itemHeight"); r(this, "lastCluster"); r(this, "scrollTop"); r(this, "dataStart"); r(this, "dataEnd"); r(this, "rows"); r(this, "destroy"); r(this, "callback"); r(this, "sanitizer"); this.rows = t.rows, this.scrollEl = t.scrollEl, this.contentEl = t.contentEl, this.parentEl = t.contentEl?.parentElement, this.callback = t.callback, this.cache = {}, this.scrollTop = this.scrollEl.scrollTop, this.initDOM(this.rows), this.scrollEl.scrollTop = this.scrollTop, this.lastCluster = 0; let e = () => { this.lastCluster !== (this.lastCluster = this.getNum()) && (this.initDOM(this.rows), this.callback()) }; this.scrollEl.addEventListener("scroll", e, !1), this.destroy = () => { this.scrollEl.removeEventListener("scroll", e, !1), g(this.contentEl) } } reset(t) { this.lastCluster = 0, this.cache = {}, g(this.contentEl), this.initDOM(t) } initDOM(t) { if (typeof this.clusterHeight > "u") { this.cache.scrollTop = this.scrollEl.scrollTop; let n = y(t[0]); this.contentEl.appendChild(n), this.contentEl.appendChild(n), this.contentEl.appendChild(n), this.cache.data = [t[0]], this.getRowsHeight() } let e = this.initData(t, this.getNum()), i = this.checkChanges("data", e.rows), s = this.checkChanges("top", e.topOffset), l = this.checkChanges("bottom", e.bottomOffset); g(this.contentEl), i && s ? (e.topOffset && this.contentEl.appendChild(this.getExtra("top", e.topOffset)), e.rows.forEach(n => this.contentEl.appendChild(y(n))), e.bottomOffset && this.contentEl.appendChild(this.getExtra("bottom", e.bottomOffset))) : l && this.contentEl.lastChild && (this.contentEl.lastChild.style.height = `${e.bottomOffset}px`) } getRowsHeight() { if (typeof this.itemHeight > "u") { let t = this.parentEl?.style.display || ""; this.parentEl && (t === "" || t === "none") && (this.parentEl.style.display = "block"); let e = this.contentEl.children, i = e[Math.floor(e.length / 2)]; this.itemHeight = i.offsetHeight, this.parentEl && (this.parentEl.style.display = t) } this.blockHeight = this.itemHeight * m.BLOCK_ROWS, this.clusterRows = m.BLOCK_ROWS * m.CLUSTER_BLOCKS, this.clusterHeight = this.blockHeight * m.CLUSTER_BLOCKS } getNum() { this.scrollTop = this.scrollEl.scrollTop; let t = (this.clusterHeight || 0) - (this.blockHeight || 0); return t && Math.floor(this.scrollTop / t) || 0 } initData(t, e) { if (t.length < m.BLOCK_ROWS) return { topOffset: 0, bottomOffset: 0, rowsAbove: 0, rows: t }; let i = Math.max((this.clusterRows - m.BLOCK_ROWS) * e, 0), s = i + this.clusterRows, l = Math.max(i * this.itemHeight, 0), n = Math.max((t.length - s) * this.itemHeight, 0), a = [], h = i; l < 1 && h++; for (let c = i; c < s; c++)t[c] && a.push(t[c]); return this.dataStart = i, this.dataEnd = s, { topOffset: l, bottomOffset: n, rowsAbove: h, rows: a } } checkChanges(t, e) { let i = e !== this.cache[t]; return this.cache[t] = e, i } getExtra(t, e) { let i = document.createElement("li"); return i.className = `virtual-scroll-${t}`, e && (i.style.height = `${e}px`), i } }; var M = ".ms-select-all, ul li[data-key]", ht = ".ms-select-all.highlighted, ul li[data-key].highlighted", w = class { constructor(t, e) { this.elm = t; r(this, "_bindEventService"); r(this, "isAllSelected", !1); r(this, "isPartiallyAllSelected", !1); r(this, "fromHtml", !1); r(this, "choiceElm"); r(this, "selectClearElm"); r(this, "closeElm"); r(this, "clearSearchIconElm"); r(this, "filterText", ""); r(this, "updateData", []); r(this, "data", []); r(this, "dataTotal"); r(this, "dropElm"); r(this, "okButtonElm"); r(this, "filterParentElm"); r(this, "lastFocusedItemKey", ""); r(this, "lastMouseOverPosition", ""); r(this, "ulElm"); r(this, "parentElm"); r(this, "labelElm"); r(this, "selectAllParentElm"); r(this, "selectAllElm"); r(this, "searchInputElm"); r(this, "selectGroupElms"); r(this, "selectItemElms"); r(this, "noResultsElm"); r(this, "options"); r(this, "selectAllName", ""); r(this, "selectGroupName", ""); r(this, "selectItemName", ""); r(this, "scrolledByMouse", !1); r(this, "openDelayTimer"); r(this, "updateDataStart"); r(this, "updateDataEnd"); r(this, "virtualScroll"); r(this, "_currentHighlightIndex", -1); r(this, "_currentSelectedElm"); r(this, "isMoveUpRecalcRequired", !1); r(this, "locales", {}); this.options = Object.assign({}, m.DEFAULTS, this.elm.dataset, e), this._bindEventService = new S({ distinctEvent: !0 }) } get isRenderAsHtml() { return this.options.renderOptionLabelAsHtml || this.options.useSelectOptionLabelToHtml } init() { this.initLocale(), this.initContainer(), this.initData(), this.initSelected(!0), this.initFilter(), this.initDrop(), this.initView(), this.options.onAfterCreate() } destroy(t = !0) { this.elm && this.parentElm && (this.options.onDestroy({ hardDestroy: t }), t && this.options.onHardDestroy(), this.elm.parentElement && this.parentElm.parentElement && this.elm.parentElement.insertBefore(this.elm, this.parentElm.parentElement.firstChild), this.elm.classList.remove("ms-offscreen"), this._bindEventService.unbindAll(), this.virtualScroll?.destroy(), this.dropElm?.remove(), this.dropElm = void 0, this.parentElm.parentNode?.removeChild(this.parentElm), this.fromHtml && (delete this.options.data, this.fromHtml = !1), this.options.onAfterDestroy({ hardDestroy: t }), t && (this.options.onAfterHardDestroy?.(), Object.keys(this.options).forEach(e => delete this[e]))) } initLocale() { if (this.options.locale) { if (typeof this.options.locale == "object") { Object.assign(this.options, this.options.locale); return } let t = window.multipleSelect.locales, e = this.options.locale.split(/-|_/); if (e[0] = e[0].toLowerCase(), e[1] && (e[1] = e[1].toUpperCase()), t[this.options.locale]) Object.assign(this.options, t[this.options.locale]); else if (t[e.join("-")]) Object.assign(this.options, t[e.join("-")]); else if (t[e[0]]) Object.assign(this.options, t[e[0]]); else throw new Error(`[multiple-select-vanilla] invalid locales "${this.options.locale}", make sure to import it before using it`) } } initContainer() { let t = this.elm.getAttribute("name") || this.options.name || ""; this.options.classes && this.elm.classList.add(this.options.classes), this.options.classPrefix && (this.elm.classList.add(this.options.classPrefix), this.options.size && this.elm.classList.add(`${this.options.classPrefix}-${this.options.size}`)), this.elm.style.display = "none", this.labelElm = this.elm.closest("label"), !this.labelElm && this.elm.id && (this.labelElm = document.createElement("label"), this.labelElm.htmlFor = this.elm.id), this.labelElm?.querySelector("input") && (this.labelElm = null), typeof this.options.single > "u" && (this.options.single = !this.elm.multiple), this.parentElm = p("div", { className: O(`ms-parent ${this.elm.className || ""} ${this.options.classes}`).join(" "), dataset: { test: "sel" } }), this.options.darkMode && this.parentElm.classList.add("ms-dark-mode"); let e = this.elm.getAttribute("title") || ""; e && (this.parentElm.title = e), this.options.placeholder = this.options.placeholder || this.elm.getAttribute("placeholder") || "", this.choiceElm = p("button", { className: "ms-choice", type: "button" }, this.parentElm), this.options.labelId && (this.choiceElm.id = this.options.labelId, this.choiceElm.setAttribute("aria-labelledby", this.options.labelId)), this.choiceElm.appendChild(p("span", { className: "ms-placeholder", textContent: this.options.placeholder })), this.options.showClear && (this.selectClearElm = p("div", { className: "ms-icon ms-icon-close" }), this.selectClearElm.style.display = "none", this.choiceElm.appendChild(this.selectClearElm)), this.choiceElm.appendChild(p("div", { className: "ms-icon ms-icon-caret" })), this.dropElm = p("div", { className: `ms-drop ${this.options.position}`, ariaExpanded: "false" }, this.parentElm), this.options.darkMode && this.dropElm.classList.add("ms-dark-mode"), t && (this.dropElm.dataset.name = t); let i = this.elm.getAttribute("data-test") || this.options.dataTest; i && (this.parentElm.dataset.test = i, this.dropElm.dataset.test = i), this.closeElm = this.choiceElm.querySelector(".ms-icon-close"), this.options.dropWidth && (this.dropElm.style.width = typeof this.options.dropWidth == "string" ? this.options.dropWidth : `${this.options.dropWidth}px`), q(this.elm, this.parentElm), this.elm.disabled && (this.choiceElm.classList.add("disabled"), this.choiceElm.disabled = !0), this.selectAllName = `selectAll${t}`, this.selectGroupName = `selectGroup${t}`, this.selectItemName = `selectItem${t}`, this.options.keepOpen || (this._bindEventService.unbindAll("body-click"), this._bindEventService.bind(document.body, "click", s => { this.getEventTarget(s) === this.choiceElm || N(this.getEventTarget(s), ".ms-choice") === this.choiceElm || (this.getEventTarget(s) === this.dropElm || N(this.getEventTarget(s), ".ms-drop") !== this.dropElm && this.getEventTarget(s) !== this.elm) && this.options.isOpen && this.close("body.click") }, void 0, "body-click")) } initData() { let t = []; if (this.options.data) { if (Array.isArray(this.options.data)) this.data = this.options.data.map(e => typeof e == "string" || typeof e == "number" ? { text: e, value: e } : e); else if (typeof this.options.data == "object") { for (let [e, i] of Object.entries(this.options.data)) t.push({ value: e, text: `${i}` }); this.data = t } } else this.elm.childNodes.forEach(e => { let i = this.initRow(e); i && t.push(i) }), this.options.data = t, this.data = t, this.fromHtml = !0; this.dataTotal = W(this.data || []) } initRow(t, e) { let i = {}; return t.tagName?.toLowerCase() === "option" ? (i.type = "option", i.text = this.options.textTemplate(t), i.value = t.value, i.visible = !0, i.selected = !!t.selected, i.disabled = e || t.disabled, i.classes = t.getAttribute("class") || "", i.title = t.getAttribute("title") || "", t.dataset.value && (i._value = t.dataset.value), Object.keys(t.dataset).length && (i._data = t.dataset, i._data.divider && (i.divider = i._data.divider)), i) : t.tagName?.toLowerCase() === "optgroup" ? (i.type = "optgroup", i.label = this.options.labelTemplate(t), i.visible = !0, i.selected = !!t.selected, i.disabled = t.disabled, i.children = [], Object.keys(t.dataset).length && (i._data = t.dataset), t.childNodes.forEach(s => { i.children.push(this.initRow(s, i.disabled)) }), i) : null } initDrop() { this.initList(), this.update(!0), this.options.isOpen && this.open(10), this.options.openOnHover && this.parentElm && (this._bindEventService.bind(this.parentElm, "mouseover", () => this.open(null)), this._bindEventService.bind(this.parentElm, "mouseout", () => this.close("hover.mouseout"))) } initFilter() { if (this.filterText = "", this.options.filter || !this.options.filterByDataLength) return; let t = 0; for (let e of this.data || []) e.type === "optgroup" ? t += e.children.length : t += 1; this.options.filter = t > this.options.filterByDataLength } initList() { if (this.options.filter && (this.filterParentElm = p("div", { className: "ms-search" }, this.dropElm), this.filterParentElm.appendChild(p("input", { autocomplete: "off", autocapitalize: "off", spellcheck: !1, type: "text", placeholder: this.options.filterPlaceholder || "\u{1F50E}\uFE0E" })), this.options.showSearchClear && this.filterParentElm.appendChild(p("span", { className: "ms-icon ms-icon-close" }))), this.options.selectAll && !this.options.single) { let t = this.elm.getAttribute("name") || this.options.name || ""; this.selectAllParentElm = p("div", { className: "ms-select-all", dataset: { key: "select_all" } }); let e = document.createElement("label"), s = `ms-icon ${this.isAllSelected ? "ms-icon-check" : this.isPartiallyAllSelected ? "ms-icon-minus" : "ms-icon-uncheck"}`, l = p("div", { className: "icon-checkbox-container" }, e); p("input", { type: "checkbox", ariaChecked: String(this.isAllSelected), checked: this.isAllSelected, dataset: { name: `selectAll${t}` } }, l), p("div", { className: s }, l), e.appendChild(p("span", { textContent: this.formatSelectAll() })), this.selectAllParentElm.appendChild(e), this.dropElm?.appendChild(this.selectAllParentElm) } this.ulElm = document.createElement("ul"), this.ulElm.role = "combobox", this.ulElm.ariaExpanded = "false", this.ulElm.ariaMultiSelectable = String(!this.options.single), this.dropElm?.appendChild(this.ulElm), this.options.showOkButton && !this.options.single && (this.okButtonElm = p("button", { className: "ms-ok-button", type: "button", textContent: this.formatOkButton() }, this.dropElm)), this.initListItems() } initListItems() { let t = 0, e = this.getListRows(); if (this.options.selectAll && !this.options.single && (t = -1), e.length > m.BLOCK_ROWS * m.CLUSTER_BLOCKS) { let i = this.dropElm && this.dropElm?.style.display !== "none"; !i && this.dropElm && (this.dropElm.style.left = "-10000", this.dropElm.style.display = "block", this.dropElm.ariaExpanded = "true"); let s = () => { if (this.virtualScroll) { this._currentHighlightIndex = 0, this.updateDataStart = this.virtualScroll.dataStart + t, this.updateDataEnd = this.virtualScroll.dataEnd + t, this.updateDataStart < 0 && (this.updateDataStart = 0, this._currentHighlightIndex = 0); let l = this.getDataLength(); this.updateDataEnd > l && (this.updateDataEnd = l), this.ulElm && (this.isMoveUpRecalcRequired ? this.recalculateArrowMove("up") : this.virtualScroll.dataStart > this.updateDataStart && this.recalculateArrowMove("down")) } }; this.ulElm && (this.virtualScroll ? this.virtualScroll.reset(e) : this.virtualScroll = new x({ rows: e, scrollEl: this.ulElm, contentEl: this.ulElm, sanitizer: this.options.sanitizer, callback: () => { s(), this.events() } })), s(), !i && this.dropElm && (this.dropElm.style.left = "0", this.dropElm.style.display = "none", this.dropElm.ariaExpanded = "false") } else this.ulElm && (g(this.ulElm), e.forEach(i => this.ulElm.appendChild(y(i)))), this.updateDataStart = 0, this.updateDataEnd = this.updateData.length; return this.events(), e } getEventTarget(t) { return t.composedPath ? t.composedPath()[0] : t.target } getListRows() { let t = []; return this.updateData = [], this.data?.forEach(e => t.push(...this.initListItem(e))), this.options.infiniteScroll && t.push({ tagName: "li", props: { className: "ms-infinite-option", role: "option" } }), t.push({ tagName: "li", props: { className: "ms-no-results", textContent: this.formatNoMatchesFound() } }), t } initListItem(t, e = 0) { let i = t?.title || "", s = this.options.multiple ? "multiple" : "", l = this.options.single ? "radio" : "checkbox", n = !!t?.selected, a = this.options.single && !this.options.singleRadio, h = ""; if (!t?.visible) return []; if (this.updateData.push(t), a && (h = "hide-radio "), t.selected && (h += "selected "), t.type === "optgroup") { let B = [], D; if (this.options.hideOptgroupCheckboxes || this.options.single) D = { tagName: "span", props: { dataset: { name: this.selectGroupName, key: t._key } } }; else { let A = { tagName: "input", props: { type: "checkbox", dataset: { name: this.selectGroupName, key: t._key }, checked: n, disabled: t.disabled } }; a ? D = A : D = { tagName: "div", props: { className: `icon-checkbox-container${l === "radio" ? " radio" : ""}` }, children: [A, { tagName: "div", props: { className: `ms-icon ${n ? l === "radio" ? "ms-icon-radio" : "ms-icon-check" : "ms-icon-uncheck"}` } }] } } !h.includes("hide-radio") && (this.options.hideOptgroupCheckboxes || this.options.single) && (h += "hide-radio "); let z = { tagName: "span", props: {} }; this.applyAsTextOrHtmlWhenEnabled(z.props, t.label); let V = { tagName: "li", props: { className: O(`group${this.options.single || t.disabled ? " disabled" : ""} ${h}`).join(" "), role: "option", ariaSelected: String(n), dataset: { key: t._key } }, children: [{ tagName: "label", props: { className: O(`optgroup${this.options.single || t.disabled ? " disabled" : ""}`).join(" ") }, children: [D, z] }] }, X = this.options.cssStyler(t); return X && (V.props.style = X), B.push(V), t.children.forEach(A => B.push(...this.initListItem(A, 1))), B } if (h += t.classes || "", e && this.options.single && (h += `option-level-${e} `), t.divider) return [{ tagName: "li", props: { className: "option-divider" } }]; let c = s || h ? (s + h).trim() : ""; t.disabled && (c += " disabled"); let d = `${t.disabled ? "disabled" : ""}`, u = { tagName: "span", props: {} }; this.applyAsTextOrHtmlWhenEnabled(u.props, t.text); let E = { tagName: "input", props: { type: l, value: encodeURI(t.value), dataset: { key: t._key, name: this.selectItemName }, checked: n, disabled: !!t.disabled } }; t.selected && (E.attrs = { checked: "checked" }); let tt = { tagName: "div", props: { className: `icon-checkbox-container${l === "radio" ? " radio" : ""}` }, children: [E, { tagName: "div", props: { className: `ms-icon ${E.props.checked ? l === "radio" ? "ms-icon-radio" : "ms-icon-check" : "ms-icon-uncheck"}` } }] }, P = { tagName: "li", props: { role: "option", title: i, ariaSelected: String(n), dataset: { key: t._key } }, children: [{ tagName: "label", props: { className: d }, children: [a ? E : tt, u] }] }; c && (P.props.className = c); let U = this.options.cssStyler(t); return U && (P.props.style = U), [P] } initSelected(t = !1) { let e = 0; for (let i of this.data || []) if (i.type === "optgroup") { let s = i.children.filter(l => l?.selected && !l.disabled && l.visible).length; i.children.length && (i.selected = !this.options.single && s && s === i.children.filter(l => l && !l.disabled && l.visible && !l.divider).length), e += s } else e += i.selected && !i.disabled && i.visible ? 1 : 0; this.isAllSelected = this.data?.filter(i => i.selected && !i.disabled && i.visible).length === this.data?.filter(i => !i.disabled && i.visible && !i.divider).length, this.isPartiallyAllSelected = !this.isAllSelected && e > 0, t || (this.isAllSelected ? this.options.onCheckAll() : e === 0 && this.options.onUncheckAll()) } initView() { let t; window.getComputedStyle ? (t = window.getComputedStyle(this.elm).width, t === "auto" && (t = v(this.dropElm, "outer", "width") + 20)) : t = v(this.elm, "outer", "width") + 20, this.parentElm.style.width = `${this.options.width || t}px`, this.elm.classList.add("ms-offscreen") } events() { this._bindEventService.unbindAll(["ok-button", "search-input", "select-all-checkbox", "input-checkbox-list", "group-checkbox-list", "hover-highlight", "arrow-highlight", "option-list-scroll"]), this.clearSearchIconElm = this.filterParentElm?.querySelector(".ms-icon-close"), this.searchInputElm = this.dropElm?.querySelector(".ms-search input"), this.selectAllElm = this.dropElm?.querySelector(`input[data-name="${this.selectAllName}"]`), this.selectGroupElms = this.dropElm?.querySelectorAll(`input[data-name="${this.selectGroupName}"],span[data-name="${this.selectGroupName}"]`), this.selectItemElms = this.dropElm?.querySelectorAll(`input[data-name="${this.selectItemName}"]:enabled`), this.noResultsElm = this.dropElm?.querySelector(".ms-no-results"); let t = e => { e.preventDefault(), !this.getEventTarget(e).classList.contains("ms-icon-close") && (this.options.isOpen ? this.close("toggle.close") : this.open()) }; this.labelElm && this._bindEventService.bind(this.labelElm, "click", e => { this.getEventTarget(e).nodeName.toLowerCase() === "label" && (t(e), (!this.options.filter || !this.options.isOpen) && this.focus(), e.stopPropagation()) }), this._bindEventService.bind(this.choiceElm, "click", t), this.options.onFocus && this._bindEventService.bind(this.choiceElm, "focus", this.options.onFocus), this.options.onBlur && this._bindEventService.bind(this.choiceElm, "blur", this.options.onBlur), this._bindEventService.bind(this.parentElm, "keydown", e => { e.code === "Escape" && this.handleEscapeKey() }), this.closeElm && this._bindEventService.bind(this.closeElm, "click", e => { e.preventDefault(), this._checkAll(!1, !0), this.initSelected(!1), this.updateSelected(), this.update(), this.options.onClear() }), this.clearSearchIconElm && this._bindEventService.bind(this.clearSearchIconElm, "click", e => { e.preventDefault(), this.searchInputElm && (this.searchInputElm.value = "", this.searchInputElm.focus()), this._currentHighlightIndex = -1, this.moveHighlightDown(), this.filter(), this.options.onFilterClear() }), this.searchInputElm && (this._bindEventService.bind(this.searchInputElm, "keydown", e => { e.code === "Tab" && e.shiftKey && this.close("key.shift+tab") }, void 0, "search-input"), this._bindEventService.bind(this.searchInputElm, "keyup", e => { if (this.options.filterAcceptOnEnter && ["Enter", "Space"].includes(e.code) && this.searchInputElm?.value) { if (this.options.single) { let i = []; this.selectItemElms?.forEach(s => { s.closest("li")?.style.display !== "none" && i.push(s) }), i.length && i[0].hasAttribute("data-name") && this.setSelects([i[0].value]) } else this.selectAllElm?.click(); this.close(`key.${e.code.toLowerCase()}`), this.focus(); return } this.filter() }, void 0, "search-input")), this.selectAllElm && this._bindEventService.bind(this.selectAllElm, "click", e => this._checkAll(e.currentTarget?.checked), void 0, "select-all-checkbox"), this.okButtonElm && this._bindEventService.bind(this.okButtonElm, "click", e => { t(e), e.stopPropagation() }, void 0, "ok-button"), this.selectGroupElms && this._bindEventService.bind(this.selectGroupElms, "click", e => { let i = e.currentTarget, s = i.checked, l = b(this.data, "_key", i.dataset.key); this._checkGroup(l, s), this.options.onOptgroupClick(H({ label: l.label, selected: l.selected, data: l._data, children: l.children.map(n => { if (n) return H({ text: n.text, value: n.value, selected: n.selected, disabled: n.disabled, data: n._data }) }) })) }, void 0, "group-checkbox-list"), this.selectItemElms && this._bindEventService.bind(this.selectItemElms, "click", e => { let i = e.currentTarget, s = i.checked, l = b(this.data, "_key", i.dataset.key), n = () => { this.options.single && this.options.isOpen && !this.options.keepOpen && this.close("selection") }; if (this.options.onBeforeClick(l) === !1) { n(); return } this._check(l, s), this.options.onClick(H({ text: l.text, value: l.value, selected: l.selected, data: l._data })), n() }, void 0, "input-checkbox-list"), this.lastFocusedItemKey && this.dropElm && this.dropElm.querySelector(`li[data-key=${this.lastFocusedItemKey}]`)?.focus(), this.options.navigationHighlight && this.dropElm && (this._bindEventService.bind(this.dropElm, "mouseover", e => { let i = this.getEventTarget(e).closest(".ms-select-all") || this.getEventTarget(e).closest("li"); if (this.dropElm?.contains(i) && this.lastMouseOverPosition !== `${e.clientX}:${e.clientY}`) { let s = this.dropElm?.querySelectorAll(M) || [], l = Array.from(s).findIndex(n => n.dataset.key === i.dataset.key); this._currentHighlightIndex !== l && !i.classList.contains("disabled") && (this._currentSelectedElm = i, this._currentHighlightIndex = l, this.changeCurrentOptionHighlight(i)) } this.lastMouseOverPosition = `${e.clientX}:${e.clientY}` }, void 0, "hover-highlight"), this._bindEventService.bind(this.dropElm, "keydown", e => { switch (e.key) { case "ArrowUp": e.preventDefault(), this.moveHighlightUp(); break; case "ArrowDown": e.preventDefault(), this.moveHighlightDown(); break; case "Escape": this.handleEscapeKey(); break; case "Enter": case " ": { if (document.activeElement !== this.okButtonElm) { let i = this.getEventTarget(e).closest(".ms-select-all") || this.getEventTarget(e).closest("li"); if (e.key === " " && this.options.filter || this.options.filterAcceptOnEnter && !i) return; e.preventDefault(), this._currentSelectedElm?.querySelector("input")?.click(), this.options.single && (this.choiceElm.focus(), this.lastFocusedItemKey = this.choiceElm?.dataset.key || "") } break } case "Tab": { e.preventDefault(), e.shiftKey ? document.activeElement === this.okButtonElm ? (this.focusSelectAllOrList(), this.highlightCurrentOption()) : (this.close("key.shift+tab"), this.choiceElm.focus()) : (this.changeCurrentOptionHighlight(), this.okButtonElm?.focus()); break } } }, void 0, "arrow-highlight")), this.ulElm && this.options.infiniteScroll && this._bindEventService.bind(this.ulElm, "scroll", this.infiniteScrollHandler.bind(this), void 0, "option-list-scroll") } handleEscapeKey() { this.options.keepOpen || (this.close("key.escape"), this.choiceElm.focus()) } infiniteScrollHandler(t, e, i) { let s = !1; t && this.getEventTarget(t) && this.ulElm && this.scrolledByMouse ? this.getEventTarget(t).scrollTop + this.getEventTarget(t).clientHeight === this.ulElm.scrollHeight && (s = !0) : e !== void 0 && e + 1 === i && (s = !0), s && this.ulElm && (this.virtualScroll ? this.initListItems() : this.ulElm.scrollTop = 0, this._currentHighlightIndex = 0, this.highlightCurrentOption()) } open(t = 0) { return new Promise(e => { t !== null && t >= 0 ? (window.clearTimeout(this.openDelayTimer), this.openDelayTimer = window.setTimeout(() => { this.openDrop(), e() }, t)) : (this.openDrop(), e()) }) } openDrop() { if (!this.dropElm || this.choiceElm?.classList.contains("disabled")) return; if (this.options.isOpen = !0, this.parentElm.classList.add("ms-parent-open"), this.choiceElm?.querySelector("div.ms-icon-caret")?.classList.add("open"), this.dropElm.style.display = "block", this.dropElm.ariaExpanded = "true", this.selectAllElm?.parentElement && (this.selectAllElm.parentElement.style.display = "inline-flex"), this.noResultsElm && (this.noResultsElm.style.display = "none"), this.getDataLength() || (this.selectAllElm?.parentElement && (this.selectAllElm.parentElement.style.display = "none"), this.noResultsElm && (this.noResultsElm.style.display = "block")), this.options.container) { let s = k(this.dropElm), l; this.options.container instanceof Node ? l = this.options.container : typeof this.options.container == "string" && (l = this.options.container === "body" ? document.body : document.querySelector(this.options.container)), l.appendChild(this.dropElm), this.dropElm.style.top = `${s?.top ?? 0}px`, this.dropElm.style.left = `${s?.left ?? 0}px`, this.dropElm.style.minWidth = "auto", this.dropElm.style.width = `${v(this.parentElm, "outer", "width")}px` } let t = this.options.minHeight, e = this.options.maxHeight; this.options.maxHeightUnit === "row" && (e = v(this.dropElm.querySelector("ul>li"), "outer", "height") * this.options.maxHeight), this.ulElm ??= this.dropElm.querySelector("ul"), this.ulElm && (t && (this.ulElm.style.minHeight = `${t}px`), this.ulElm.style.maxHeight = `${e}px`), this.dropElm.querySelectorAll(".multiple").forEach(s => { s.style.width = `${this.options.multipleWidth}px` }), this.getDataLength() && this.options.filter ? (this.searchInputElm && (this.searchInputElm.value = "", this.searchInputElm.focus()), this.filter(!0)) : this.focusSelectAllOrList(), this._currentHighlightIndex < 0 ? this.moveHighlightDown() : this.highlightCurrentOption(), this.options.autoAdjustDropWidthByTextSize && this.adjustDropWidthByText(); let i = this.options.position; if (this.options.autoAdjustDropHeight) { if (this.options.autoAdjustDropPosition) { let { bottom: s, top: l } = T(this.dropElm), n = this.dropElm.getBoundingClientRect().height; i = s < n && l > s ? "top" : "bottom" } this.adjustDropHeight(i) } this.options.autoAdjustDropPosition && this.adjustDropPosition(!0), this.options.onOpen() } focusSelectAllOrList() { this.selectAllElm ? this.selectAllElm.focus() : this.ulElm && (this.ulElm.tabIndex = 0, this.ulElm.focus()) } highlightCurrentOption() { let t = this.dropElm?.querySelectorAll(M) || []; if (this._currentHighlightIndex <= t.length) { let e = t[this._currentHighlightIndex]; e && (this.lastFocusedItemKey = e.dataset.key || "", this._currentSelectedElm = e, this.scrolledByMouse = !1, e.scrollIntoView({ block: "nearest" }), this.changeCurrentOptionHighlight(e), window.setTimeout(() => this.scrolledByMouse = !0, 10)) } } changeCurrentOptionHighlight(t) { t?.classList.add("highlighted"), (this.dropElm?.querySelectorAll(ht) || []).forEach(i => { i !== t && i.classList.remove("highlighted") }) } moveHighlightDown() { let t = this.dropElm?.querySelectorAll(M) || [], e = t.length; this._currentHighlightIndex < e - 1 ? (this._currentHighlightIndex++, t[this._currentHighlightIndex]?.classList.contains("disabled") && this.moveHighlightDown()) : this.options.infiniteScroll && this.infiniteScrollHandler(null, this._currentHighlightIndex, e), this.highlightCurrentOption() } moveHighlightUp() { let t = this.dropElm?.querySelectorAll(M) || [], e = this.options.single ? 0 : 1; if (this.virtualScroll && this._currentHighlightIndex <= e && this.updateDataStart > 0 && this.ulElm) { let i = t[this._currentHighlightIndex + (this.options.single ? 0 : 1)], s = i?.dataset.key; this.lastFocusedItemKey = s, this.ulElm.scrollTop = this.ulElm.scrollTop - i?.getBoundingClientRect().height || 10, this.isMoveUpRecalcRequired = !0; return } this._currentHighlightIndex > 0 && (this._currentHighlightIndex--, t[this._currentHighlightIndex]?.classList.contains("disabled") && this.moveHighlightUp()), this.highlightCurrentOption() } recalculateArrowMove(t) { let e = this.dropElm?.querySelectorAll(M) || [], i = Array.from(e).findIndex(s => s.dataset.key === this.lastFocusedItemKey); this._currentHighlightIndex = i - 1, t === "down" ? this.moveHighlightDown() : t === "up" && (this.moveHighlightUp(), this.isMoveUpRecalcRequired = !1) } close(t) { this.options.isOpen = !1, this.parentElm.classList.remove("ms-parent-open"), this.choiceElm?.querySelector("div.ms-icon-caret")?.classList.remove("open"), this.dropElm && (this.dropElm.style.display = "none", this.dropElm.ariaExpanded = "false", this.options.container && (this.parentElm.appendChild(this.dropElm), this.dropElm.style.top = "auto", this.dropElm.style.left = "auto")), this.options.onClose(t) } applyAsTextOrHtmlWhenEnabled(t, e) { t || (t = {}), this.isRenderAsHtml ? t.innerHTML = typeof this.options.sanitizer == "function" ? this.options.sanitizer(e) : e : t.textContent = e } update(t = !1) { let e = this.getSelects(), i = this.getSelects("text"); this.options.displayValues && (i = e); let s = this.choiceElm?.querySelector("span"), l = e.length, n = null, a = () => { if (this.options.useSelectOptionLabel || this.options.useSelectOptionLabelToHtml) { let c = e.join(this.options.displayDelimiter); return this.options.useSelectOptionLabelToHtml ? G(c) : c } return i.join(this.options.displayDelimiter) }; if (s) { if (l === 0) { let c = this.options.placeholder || ""; s.classList.add("ms-placeholder"), this.applyAsTextOrHtmlWhenEnabled(s, c) } else l < this.options.minimumCountSelected ? n = a() : this.formatAllSelected() && l === this.dataTotal ? n = this.formatAllSelected() : this.options.ellipsis && l > this.options.minimumCountSelected ? n = `${i.slice(0, this.options.minimumCountSelected).join(this.options.displayDelimiter)}...` : this.formatCountSelected(l, this.dataTotal) && l > this.options.minimumCountSelected ? n = this.formatCountSelected(l, this.dataTotal) : n = a(); if (n !== null && (s?.classList.remove("ms-placeholder"), this.applyAsTextOrHtmlWhenEnabled(s, n)), this.options.showClear && this.selectClearElm) { let c = n ? "block" : "none"; this.selectClearElm.style.display = c } if (this.options.displayTitle) { let c = this.options.useSelectOptionLabel || this.options.useSelectOptionLabelToHtml ? "value" : "text"; s.title = this.getSelects(c).join(this.options.displayDelimiter) } } let h = this.getSelects(); this.options.single ? this.elm.value = h.length ? h[0] : "" : Array.from(this.elm.options).forEach(c => { c.selected = h.some(d => d === c.value) }), t || this.elm.dispatchEvent(new Event("change")) } updateSelected(t) { for (let i = this.updateDataStart; i < this.updateDataEnd; i++) { let s = this.updateData[i], l = this.dropElm?.querySelector(`input[data-key=${s._key}]`); if (l) { l.checked = s.selected; let n = l.closest("li"), a = n?.querySelector(".icon-checkbox-container div"); n && (s.selected && !n.classList.contains("selected") ? (n.classList.add("selected"), n.ariaSelected = "true", a && (a.className = `ms-icon ms-icon-${l.type === "radio" ? "radio" : "check"}`)) : s.selected || (n.classList.remove("selected"), n.ariaSelected = "false", a && (a.className = "ms-icon ms-icon-uncheck"))) } } let e = this.data?.filter(i => i.visible).length === 0; if (this.selectAllElm) { this.selectAllElm.ariaChecked = String(this.isAllSelected); let i = this.dropElm?.querySelector(".ms-select-all .icon-checkbox-container div"); if (i) { let s = ""; this.isAllSelected ? s = "ms-icon-check" : this.isPartiallyAllSelected ? s = "ms-icon-minus" : s = "ms-icon-uncheck", i.className = `ms-icon ${s}` } this.selectAllElm.checked = this.isAllSelected, R(this.selectAllElm.closest("li"), !e) } R(this.noResultsElm, e), this.virtualScroll && (this.virtualScroll.rows = t ?? this.getListRows()) } getData() { return this.options.data } getDataLength() { return this.data?.length ?? 0 } getOptions(t = !0) { let e = Object.assign({}, this.options); return delete e.data, t ? L(e) : this.options } refreshOptions(t) { j(this.options, t, !0) || (this.options = Object.assign(this.options, t), this.destroy(!1), this.init()) } getDropElement() { return this.dropElm } getParentElement() { return this.parentElm } getSelects(t = "value") { let e = []; for (let i of this.data || []) if (i.type === "optgroup") { let s = i.children.filter(l => l?.selected); if (!s.length) continue; if (t === "value" || this.options.single) e.push(...s.map(l => t === "value" && l._value || l[t])); else { let l = []; l.push("["), l.push(i.label), l.push(`: ${s.map(n => n[t]).join(", ")}`), l.push("]"), e.push(l.join("")) } } else i.selected && e.push(t === "value" && i._value || i[t]); return e } setSelects(t, e = "value", i = !1) { let s = !1, l = n => { for (let a of n) { let h = !1; if (e === "text") { let c = document.createElement("div"); this.applyAsTextOrHtmlWhenEnabled(c, a.text), h = t.includes(c.textContent?.trim() ?? "") } else h = t.includes(a._value || a.value), !h && a.value === `${+a.value}` && (h = t.includes(+a.value)); a.selected !== h && (s = !0), a.selected = h } }; for (let n of this.data || []) n.type === "optgroup" ? l(n.children) : l([n]); s && (this.initSelected(i), this.updateSelected(), this.update(i)) } enable() { this.choiceElm && (this.choiceElm.classList.remove("disabled"), this.choiceElm.disabled = !1) } disable() { this.choiceElm && (this.choiceElm?.classList.add("disabled"), this.choiceElm.disabled = !0) } check(t) { let e = b(this.data, "value", t); e && this._check(e, !0) } uncheck(t) { let e = b(this.data, "value", t); e && this._check(e, !1) } _check(t, e) { this.options.single && this._checkAll(!1, !0), t.selected = e, this.initSelected(), this.updateSelected(), this.update() } checkAll() { this._checkAll(!0) } uncheckAll() { this._checkAll(!1) } _checkAll(t, e) { for (let i of this.data || []) i.type === "optgroup" ? this._checkGroup(i, t, !0) : !i.disabled && !i.divider && (e || i.visible) && (i.selected = t); e || (this.initSelected(), this.updateSelected(), this.update()) } _checkGroup(t, e, i) { t.selected = e, t.children.forEach(s => { s && !s.disabled && !s.divider && (i || s.visible) && (s.selected = e) }), i || (this.initSelected(), this.updateSelected(), this.update()) } checkInvert() { if (!this.options.single) { for (let t of this.data || []) if (t.type === "optgroup") for (let e of t.children) e && (e.divider || (e.selected = !e.selected)); else t && !t.divider && (t.selected = !t.selected); this.initSelected(), this.updateSelected(), this.update() } } focus() { this.choiceElm?.focus(), this.options.onFocus() } blur() { this.choiceElm?.blur(), this.options.onBlur() } refresh() { this.destroy(!1), this.init() } filter(t) { let e = this.searchInputElm?.value.trim() ?? "", i = e.toLowerCase(); if (this.filterText === i) return; this.filterText = i; for (let l of this.data || []) if (l.type === "optgroup") if (this.options.filterGroup) { let n = `${l?.label ?? ""}`; if (l != null) { let a = this.options.customFilter({ label: f(n.toString().toLowerCase(), this.options.diacriticParser), search: f(i, this.options.diacriticParser), originalLabel: n, originalSearch: e, row: l }); l.visible = a; for (let h of l.children) h && (h.visible = a) } } else { for (let n of l.children) if (n != null) { let a = `${n?.text ?? ""}`; n.visible = this.options.customFilter({ text: f(a.toString().toLowerCase(), this.options.diacriticParser), search: f(i, this.options.diacriticParser), originalText: a, originalSearch: e, row: n, parent: l }) } l.visible = l.children.filter(n => n?.visible).length > 0 } else { let n = `${l?.text ?? ""}`; l.visible = this.options.customFilter({ text: f(n.toString().toLowerCase(), this.options.diacriticParser), search: f(i, this.options.diacriticParser), originalText: n, originalSearch: e, row: l }) } let s = this.initListItems(); this.initSelected(t), this.updateSelected(s), t || this.options.onFilter(e) } adjustDropHeight(t) { let e = t !== "top", i = this.filterParentElm?.getBoundingClientRect().height ?? 0, s = this.okButtonElm?.getBoundingClientRect().height ?? 0, l = this.options.single ? 0 : this.selectAllParentElm?.getBoundingClientRect().height ?? 0, n = i + s + l + 5, { bottom: a, top: h } = T(this.parentElm), c = this.options.maxHeight; if (e ? c = a - n - this.options.adjustedHeightPadding : c = h - n - this.options.adjustedHeightPadding, !this.options.maxHeight || this.options.maxHeight && c < this.options.maxHeight) { let d = this.dropElm?.querySelector("ul"); return d && (d.style.maxHeight = `${c}px`), !0 } return !1 } adjustDropPosition(t) { let e = "bottom"; if (this.dropElm && this.parentElm) { let { bottom: i, top: s } = T(this.dropElm), { top: l, left: n } = k(this.parentElm), a = this.dropElm.getBoundingClientRect().height, h = this.dropElm.getBoundingClientRect().width, c = document.body.offsetWidth || window.innerWidth, d = this.parentElm.getBoundingClientRect().width; if (i > a) e = "bottom"; else if (a > i && s > i) { if (this.options.container) { let u = l - a; u < 0 && (u = 0), (u > 0 || t) && (e = "top", this.dropElm.style.top = `${u < 0 ? 0 : u}px`) } else e = "top", this.dropElm.classList.add(e); this.dropElm.classList.remove("bottom") } c - h < n && (this.dropElm.style.left = `${n - (h - d)}px`) } return e } adjustDropWidthByText() { if (this.dropElm) { let e = this.parentElm.scrollWidth; (this.options.dropWidth || this.options.width) && (e = this.options.dropWidth || this.options.width || 0); let i = this.dropElm.querySelector(".ms-select-all span"), s = this.dropElm.querySelector("ul"), l = 26, n = i?.clientWidth ?? 0 + l, h = s.scrollHeight > s.clientHeight ? this.getScrollbarWidth() : 0, c = 0; this.dropElm.querySelectorAll("li label").forEach(d => { d.scrollWidth > c && (c = d.scrollWidth) }), c += l + h, c < n && (c = n), this.options.maxWidth && c > this.options.maxWidth && (c = this.options.maxWidth), this.options.minWidth && c < this.options.minWidth && (c = this.options.minWidth), (e === "100%" || +e < c) && (this.dropElm.style.width = `${c}px`, this.dropElm.style.maxWidth = `${c}px`) } } getScrollbarWidth() { let t = document.createElement("div"); t.style.visibility = "hidden", t.style.width = "100px", document.body.appendChild(t); let e = t.offsetWidth; t.style.overflow = "scroll"; let i = document.createElement("div"); i.style.width = "100%", t.appendChild(i); let s = i.offsetWidth; return t.parentNode?.removeChild(t), e - s } formatAllSelected() { return this.options.allSelectedText || this.options.formatAllSelected() } formatCountSelected(t, e) { return this.options.countSelectedText ? this.options.countSelectedText.replace("#", `${t}`).replace("%", `${e}`) : this.options.formatCountSelected(t, e) } formatNoMatchesFound() { return this.options.noMatchesFoundText || this.options.formatNoMatchesFound() } formatOkButton() { return this.options.okButtonText || this.options.formatOkButton() } formatSelectAll() { return this.options.selectAllText || this.options.formatSelectAll() } }; var C = (o, t) => typeof o == "string" ? K(document.querySelectorAll(o), t) : o instanceof Node ? K([o], t) : K(o, t); function K(o, t) { let e = Array.from(o), i = []; for (let s = 0; s < e.length; s++) { let l = e[s]; try { l._multipleSelect !== void 0 && (l._multipleSelect.destroy(), delete l._multipleSelect), l._multipleSelect = new w(l, t || {}), l._multipleSelect.init(); let n = l._multipleSelect.getOptions(!1); n.onHardDestroy = () => delete l._multipleSelect, n.onAfterHardDestroyed = () => i[s] = null, i.push(l._multipleSelect) } catch (n) { console.error(n) } } return i.length === 1 ? i[0] : i } C.defaults = m.DEFAULTS; C.locales = { ..._ }; C.methods = m.METHODS; typeof window < "u" && (window.multipleSelect = C); export { S as BindingEventService, w as MultipleSelectInstance, x as VirtualScroll, T as calculateAvailableSpace, O as classNameToList, j as compareObjects, y as convertItemRowToHtml, p as createDomElement, F as createDomStructure, L as deepCopy, g as emptyElement, b as findByParam, N as findParent, k as getElementOffset, v as getElementSize, q as insertAfter, I as isDefined, C as multipleSelect, $ as objectRemoveEmptyProps, Q as omitProp, f as removeDiacritics, H as removeUndefined, W as setDataKeys, G as stripScripts, at as toCamelCase, R as toggleElement, ct as toggleElementClass, Z as windowScrollPosition };
//# sourceMappingURL=multiple-select.js.map
